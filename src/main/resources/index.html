<!DOCTYPE html>
<html>
<meta charset = "utf-8" />
<title>GDAX Realtime Market Watcher</title>
<script src="https://cdn.bootcss.com/Chart.js/2.7.1/Chart.bundle.js"></script>
<script type="text/javascript">
      //var wsUri = "ws://" + window.location.host + "/api/v0/websocket";
      var wsUri = "ws://localhost:9025/api/v0/websocket";
      var decoder = new TextDecoder("UTF-8");
      var output;
      var marketSells = [];
      var marketBuys = [];
      var lastTradePrices = [];
      var bestBids = [];
      var bestAsks = [];
      var maxLen = 1250;
      var scatterChart;
      var lastTradePrice = 0;
      function init() {
        output = document.getElementById("output");
        initWs();
        var ctx = document.getElementById("chart").getContext('2d');
        scatterChart = new Chart(ctx, {
            type: 'bubble',
            data: {
                datasets: [
                  {
                    label: 'Market Sell [USD]',
                    data: marketSells,
                    yAxisID: "MarketOrders",
                    radius: 30,
                    backgroundColor: "rgba(196, 93, 105, 0.3)"
                  },
                  {
                    label: 'Market Buy [USD]',
                    data: marketBuys,
                    yAxisID: "MarketOrders",
                    radius: 30,
                    backgroundColor: "rgba(32, 162, 219, 0.3)"
                  },
                  {
                    type: 'line',
                    fill: 'start',
                    steppedLine: 'after',
                    backgroundColor: "rgba(70, 80, 191, 0.3)",
                    label: 'Best Bid',
                    pointRadius: 0,
                    pointHoverRadius: 0,
                    yAxisID: "TradePrice",
                    data: bestBids,
                  },
                  {
                    type: 'line',
                    fill: 'end',
                    steppedLine: 'after',
                    backgroundColor: "rgba(237, 179, 99, 0.3)",
                    label: 'Best Ask',
                    yAxisID: "TradePrice",
                    pointRadius: 0,
                    pointHoverRadius: 0,
                    data: bestAsks,
                  },
                  {
                    type: 'line',
                    fill: false,
                    backgroundColor: "rgb(110, 53, 224)",
                    borderColor: "rgb(110, 53, 224)",
                    pointRadius: 0,
                    pointHoverRadius: 0,
                    borderDash: [5, 5],
                    label: 'Last Trade Price',
                    yAxisID: "TradePrice",
                    data: lastTradePrices,
                  }
                ]
            },
            options: {
            animation: {
                duration: 1,
                onComplete: function () {
                    var chartInstance = this.chart,
                        ctx = chartInstance.ctx;
                    ctx.font = Chart.helpers.fontString(Chart.defaults.global.defaultFontSize, Chart.defaults.global.defaultFontStyle, Chart.defaults.global.defaultFontFamily);
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';

                    var mss = chartInstance.controller.getDatasetMeta(0);
                    var mbs = chartInstance.controller.getDatasetMeta(1);
                    mbs.data.forEach(function (bar, index) {
                      if (index >= marketBuys.length)
                        return;
                      var data = marketBuys[index]['y'];
                      ctx.fillStyle = "#000000";
                      ctx.font = "bold 12px verdana, sans-serif";
                      ctx.fillText(Math.round(data), bar._model.x + 1, bar._model.y);
                    });
                    mss.data.forEach(function (bar, index) {
                      if (index >= marketSells.length)
                        return;
                      var data = marketSells[index]['y'];
                      ctx.fillStyle = "#000000";
                      ctx.font = "bold 12px verdana, sans-serif";
                      ctx.fillText(Math.round(data), bar._model.x + 1, bar._model.y);
                    });
                  }
                },
                tooltips: {
                  enabled: false
                },
                scales: {
                    xAxes: [{
                        gridLines: { display: false },
                        ticks: {
                          autoSkip: false, maxRotation: 0, minRotation: 0,
                          steps: 5, stepValue: 2,
                        },
                        type: 'time',
                        distribution: 'series',
                        position: 'bottom',
                        barThickness: 20,
                    }],
                    yAxes: [
                     {
                        gridLines: { display: false },
                        type: "linear",
                        display: true,
                        position: "left",
                        id: "MarketOrders",
                     },
                     {
                        gridLines: { display: false },
                        type: "linear",
                        display: true,
                        position: "right",
                        id: "TradePrice",
                     }
                    ]
                }
            }
        });
        updateChart();
      }

      function initWs() {
         websocket = new WebSocket(wsUri);
         websocket.binaryType = 'arraybuffer';
         websocket.onopen = function(evt) {
            onOpen(evt)
         };

         websocket.onclose = function(evt) {
            onClose(evt)
         };

         websocket.onmessage = function(evt) {
            onMessage(evt)
         };

         websocket.onerror = function(evt) {
            onError(evt)
         };
      }

      function updateChart() {
         scatterChart.update(0);
         setTimeout(updateChart, 40);
      }

      function onOpen(evt) {
         writeToScreen("CONNECTED");
      }

      function onClose(evt) {
         writeToScreen("DISCONNECTED");
      }

      function onMessage(evt) {
         var decoded = decoder.decode(evt.data);
         var parsed = JSON.parse(decoded);
         var msg = parsed['message'];
         if (msg == null)
           return;

         var type = msg['type'];
         if (type == null)
           return;

         while (lastTradePrices.length >= maxLen) {
           lastTradePrices.shift();
         }

          if (lastTradePrices.length > 0) {
               var headDate = lastTradePrices[0]['x'].getTime();
               while (marketSells.length > 0 && headDate - marketSells[0]['x'].getTime() > 0) {
                 marketSells.shift();
               }
               while (marketBuys.length > 0 && headDate - marketBuys[0]['x'].getTime() > 0) {
                 marketBuys.shift();
               }
               while (bestAsks.length > 0 && headDate - bestAsks[0]['x'].getTime() > 0) {
                 bestAsks.shift();
               }
               while (bestBids.length > 0 && headDate - bestBids[0]['x'].getTime() > 0) {
                 bestBids.shift();
               }
          }

         var now = new Date();
         if (type == "t") {
           var ltp = msg['price'];
           var bb = msg["bestBid"];
           var ba = msg["bestAsk"];
           if (ltp != null && bb != null && ba != null) {
             // TODO: workaround
             if (Math.abs(ltp-bb) > 150 || Math.abs(ltp-ba) > 150 ) {
               console.log("ignored");
               return;
             }
             /*if (lastTradePrices.length > 0) {
               var prevLtp = lastTradePrices[lastTradePrices.length-1];
               if (prevLtp['y'] == ltp && now.getTime() - prevLtp['x'].getTime() < 100) {
                 lastTradePrices.pop();
               }
             }*/
             lastTradePrices.push({x: now, y: ltp});
             /*if (bestAsks.length > 0) {
               var prevBa = bestAsks[bestAsks.length-1];
               if (prevBa['y'] == ba && now.getTime() - prevBa['x'].getTime() < 100) {
                 bestAsks.pop();
               }
             }*/
             bestAsks.push({x: now, y: ba});
             /*if (bestBids.length > 0) {
               var prevBb = bestBids[bestBids.length-1];
               if (prevBb['y'] == bb && now.getTime() - prevBb['x'].getTime() < 100) {
                 bestBids.pop();
               }
             }*/
             bestBids.push({x: now, y: bb});
           }
         }
         else if (type == "m" && lastTradePrices.length > 0) {
             var side = msg['side'];
             if (side == null)
               return;
             if (side == "s") {
                 var sellUsd = msg['amount'];
                 if (sellUsd != null) {
                   marketSells.push({x: new Date(), y: sellUsd});
                 }
             }
             else if (side == "b") {
                var buyUsd = msg['amount'];
                if (buyUsd != null) {
                  marketBuys.push({x: new Date(), y: buyUsd});
                }
             }
         }
      }

      function onError(evt) {
         writeToScreen('<span style = "color: red;">ERROR:</span> ' + evt.data);
      }

      function doSend(message) {
         websocket.send(message);
         writeToScreen("SENT: " + message);
      }

      function writeToScreen(message) {
         var pre = document.createElement("p");
         pre.style.wordWrap = "break-word";
         pre.innerHTML = message;
         output.appendChild(pre);
      }

      function histSize(mult) {
         maxLen = maxLen * mult;
      }

      window.addEventListener("load", init, false);
   </script>

<h2>GDAX Realtime Market Watcher</h2>
<canvas id="chart" width="960" height="400"></canvas>
<div id="output"></div>
<button onClick="histSize(2)">Increase history size</button>
<button onClick="histSize(1/2)">Decrease history size</button>
</html>